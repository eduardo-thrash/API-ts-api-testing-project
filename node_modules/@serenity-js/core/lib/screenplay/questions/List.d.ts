import type { UsesAbilities } from '../abilities';
import type { Actor } from '../Actor';
import type { Answerable } from '../Answerable';
import type { QuestionAdapter } from '../Question';
import { Question } from '../Question';
import type { AnswersQuestions } from '../questions';
import { Task } from '../Task';
import type { Expectation } from './Expectation';
import type { MetaQuestion } from './MetaQuestion';
/**
 * Serenity/JS Screenplay Pattern-style wrapper around {@apilink Array}
 * and array-like structures - see {@apilink PageElements}.
 *
 * @group Questions
 */
export declare class List<Item_Type> extends Question<Promise<Item_Type[]>> {
    protected readonly collection: Answerable<Array<Item_Type>>;
    private subject;
    static of<IT>(collection: Answerable<Array<IT>>): List<IT>;
    constructor(collection: Answerable<Array<Item_Type>>);
    eachMappedTo<Mapped_Item_Type>(question: MetaQuestion<Item_Type, Promise<Mapped_Item_Type> | Mapped_Item_Type>): List<Mapped_Item_Type>;
    forEach(callback: (current: CurrentItem<Item_Type>, index: number, items: Array<Item_Type>) => Promise<void> | void): Task;
    where<Answer_Type>(question: MetaQuestion<Item_Type, Promise<Answer_Type> | Answer_Type>, expectation: Expectation<Answer_Type>): this;
    count(): QuestionAdapter<number>;
    first(): QuestionAdapter<Item_Type>;
    last(): QuestionAdapter<Item_Type>;
    nth(index: number): QuestionAdapter<Item_Type>;
    answeredBy(actor: AnswersQuestions & UsesAbilities): Promise<Array<Item_Type>>;
    describedAs(subject: string): this;
    toString(): string;
}
/**
 * @group Questions
 */
export interface CurrentItem<Item_Type> {
    item: Item_Type;
    actor: Actor;
}
//# sourceMappingURL=List.d.ts.map